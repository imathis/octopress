<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MongoDB | Avi Tzurel]]></title>
  <link href="http://avi.io/blog/categories/mongodb/atom.xml" rel="self"/>
  <link href="http://avi.io/"/>
  <updated>2013-01-30T20:39:35+02:00</updated>
  <id>http://avi.io/</id>
  <author>
    <name><![CDATA[Avi Tzurel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Problems with Mongoid and Sidekiq- Brainstorming]]></title>
    <link href="http://avi.io/blog/2013/01/30/problems-with-mongoid-and-sidekiq-brainstorming/"/>
    <updated>2013-01-30T20:13:00+02:00</updated>
    <id>http://avi.io/blog/2013/01/30/problems-with-mongoid-and-sidekiq-brainstorming</id>
    <content type="html"><![CDATA[<p>A few weeks back, we started slowly upgrading all of our queues to work with Sidekiq.</p>

<p>Posts on how awesome the experience was and how much better Sidekiq is from Resque coming soon, though with all the good came some bad.</p>

<h2>Summary of the solution</h2>

<p>With Sidekiq, we are processing around 25X more jobs than what we were doing with Resque, processing around 15,000,000 jobs per day, at paces of over 1K per second at times (at peak we go up well past that)</p>

<p>This is how many jobs we processed todayâ€¦</p>

<p><img src="http://d.pr/i/O9aU+" alt="Sidekiq history graph for today" /></p>

<p>And this is a snapshot of our realtime graph</p>

<p><img src="http://d.pr/i/7Fkr+" alt="Realtime graph snapshot" /></p>

<p>On the MongoDB side we are working with Mongoid and we have a shared environment, 9 shards with 3 replicas in each shard, all running through 2 routers.</p>

<p>Our production mongoid config looks like this</p>

<p>```yaml
production:
  op_timeout: 3
  connection_timeout: 3
  sessions:</p>

<pre><code>default:
  hosts:
    - HOST_NAME:27017 #Single router R0
  username: USER_NAME
  password: PASSWORD
  database: DATABASE_NAME
  options:
    consistency: :eventual
</code></pre>

<p>```</p>

<p>We are using latest versions of all relevant gems (Sidekiq, Mongoid, Moped, Redis)</p>

<h2>All seems fine right? What's the problem?</h2>

<p>The problem is that we have too many connections opening and closing to our mongo instances. (~25-40 new connections per second).</p>

<p>Each time a job is picked up, a connection to Mongo is opened and when the job is done, this connection is closed (using Kiqstand middleware).</p>

<p>This is causing huge loads on our router server, and causing mongo to run out of file descriptors at times.</p>

<h2>SO?</h2>

<p>More then anything, this post is a callout for discussion with anyone using similar solution with similar scale and can assist, I know I would love to brainstorm on how to solve this problem.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using MongoDB aggregation framework #1]]></title>
    <link href="http://avi.io/blog/2013/01/16/using-mongodb-aggregation-framework-number-1/"/>
    <updated>2013-01-16T21:09:00+02:00</updated>
    <id>http://avi.io/blog/2013/01/16/using-mongodb-aggregation-framework-number-1</id>
    <content type="html"><![CDATA[<p>A little while ago, I started implementing the graph behind <a href="http://gogobot.com">Gogobot</a>.</p>

<p>When you see any page on the site (Logged in), all of what you see is completely personalized to you and is based on what your friends are doing/done before.</p>

<p>Whether your friends are on Gogobot or not, if you connect to Facebook/Foursquare we will calculate the score for all places based on your friends.</p>

<p>Unlike other sites, we will promote what your friends are doing and not what random users are doing, this way, when you see a review written by a face you recognize, the likelihood for fraudulent reviews is slim.</p>

<p>We had this graph since day one, but as we scaled up and started taking more and more things into account while calculating the score, we needed a different solution.</p>

<p>A few months ago, I sat down to plan this solution and the architecture behind it basically from scratch.</p>

<p>I will not get into the details here, posts on this subject are probably coming soon, just wanted to lay out a few examples of how I'm using the new <a href="http://docs.mongodb.org/manual/applications/aggregation/">MongoDB aggregation framework</a>.</p>

<p>The MongoDB aggregation framework is a new way to aggregate data from MongoDB without actually using MapReduce or needing to export the data and using <a href="http://aws.amazon.com/elasticmapreduce/">Amazon ElasticMapReduce</a>.</p>

<p>While we do use those solutions for more complex stuff, for a lot of things, we use the Aggregation framework and it's proven to be a pretty powerful solution.</p>

<p>OK, so here's a nice example of the power of the Aggregation Framework (including benchmarks)</p>
]]></content>
  </entry>
  
</feed>
